From fcb3b4ce5231218bcf949da4270bd85a2cfb3535 Mon Sep 17 00:00:00 2001
From: Yonit Halperin <yhalperi@redhat.com>
Date: Sun, 18 Sep 2011 14:52:04 +0300
Subject: [PATCH 14/23] client: rewrite surfaces cache

use std::map instead of a specific template (CHash).
There is no need for special template. Moreover, using
std::map will allow easy iteration over the surfaces.
---
 client/canvas.cpp          |   25 +++++++-
 client/canvas.h            |  152 ++++----------------------------------------
 client/display_channel.cpp |  149 +++++++++++++++----------------------------
 client/display_channel.h   |   18 +-----
 client/red_gdi_canvas.cpp  |    4 +-
 client/red_gdi_canvas.h    |    2 +-
 client/red_gl_canvas.cpp   |    4 +-
 client/red_gl_canvas.h     |    2 +-
 client/red_sw_canvas.cpp   |    6 +-
 client/red_sw_canvas.h     |    2 +-
 10 files changed, 101 insertions(+), 263 deletions(-)

diff --git a/client/canvas.cpp b/client/canvas.cpp
index 284a814..6a50a32 100644
--- a/client/canvas.cpp
+++ b/client/canvas.cpp
@@ -21,14 +21,35 @@
 #include "utils.h"
 #include "debug.h"

+static SpiceCanvas* surfaces_cache_op_get(SpiceImageSurfaces *surfaces, uint32_t surface_id)
+{
+    SurfacesCache* surfaces_cache = static_cast<SurfacesCache*>(surfaces);
+    if (!surfaces_cache->exist(surface_id)) {
+        return NULL;
+    }
+    return (*surfaces_cache)[surface_id]->get_internal_canvas();
+}
+
+SurfacesCache::SurfacesCache()
+{
+    static SpiceImageSurfacesOps surfaces_ops = {
+        surfaces_cache_op_get,
+    };
+    ops = &surfaces_ops;
+}
+
+bool SurfacesCache::exist(uint32_t surface_id)
+{
+    return (this->count(surface_id) != 0);
+}

 Canvas::Canvas(PixmapCache& pixmap_cache, PaletteCache& palette_cache,
-               GlzDecoderWindow &glz_decoder_window, CSurfaces &csurfaces)
+               GlzDecoderWindow &glz_decoder_window, SurfacesCache &csurfaces)
     : _canvas (NULL)
     , _pixmap_cache (pixmap_cache)
     , _palette_cache (palette_cache)
     , _glz_decoder(glz_decoder_window, _glz_handler, _glz_debug)
-    , _csurfaces(csurfaces)
+    , _surfaces_cache(csurfaces)
 {
 }

diff --git a/client/canvas.h b/client/canvas.h
index 4844c31..5deafda 100644
--- a/client/canvas.h
+++ b/client/canvas.h
@@ -31,6 +31,7 @@
 #include "glz_decoder.h"
 #include "jpeg_decoder.h"
 #include "zlib_decoder.h"
+#include <map>

 enum CanvasType {
     CANVAS_TYPE_INVALID,
@@ -39,102 +40,6 @@ enum CanvasType {
     CANVAS_TYPE_GDI,
 };

-template <class T, int HASH_SIZE, class Base = EmptyBase>
-class CHash : public Base {
-public:
-    CHash()
-    {
-        memset(_hash, 0, sizeof(_hash));
-    }
-
-    ~CHash()
-    {
-    }
-
-    void add(uint32_t id, T* data)
-    {
-        Item** item = &_hash[key(id)];
-
-        while (*item) {
-            PANIC_ON((*item)->id == id);
-            item = &(*item)->next;
-        }
-        *item = new Item(id, data);
-    }
-
-    bool is_present(uint32_t id)
-    {
-        Item* item = _hash[key(id)];
-
-        for (;;) {
-            if (!item) {
-                return false;
-            }
-
-            if (item->id != id) {
-                item = item->next;
-                continue;
-            }
-
-            return true;
-        }
-    }
-
-    T* get(uint32_t id)
-    {
-        Item* item = _hash[key(id)];
-
-        for (;;) {
-            PANIC_ON(!item);
-
-            if (item->id != id) {
-                item = item->next;
-                continue;
-            }
-
-            return item->data;
-        }
-    }
-
-    void remove(uint32_t id)
-    {
-        Item** item = &_hash[key(id)];
-
-        while (*item) {
-            if ((*item)->id == id) {
-                Item *rm_item = *item;
-                *item = rm_item->next;
-                delete rm_item;
-                return;
-            }
-            item = &(*item)->next;
-        }
-        THROW("id %lu, not found", id);
-    }
-
-private:
-    inline uint32_t key(uint32_t id) {return id % HASH_SIZE;}
-
-private:
-    class Item {
-    public:
-        Item(uint32_t in_id, T* data)
-            : id (in_id)
-            , next (NULL)
-            , data (data) {}
-
-        ~Item()
-        {
-        }
-
-        uint64_t id;
-        Item* next;
-        T* data;
-    };
-
-    Item* _hash[HASH_SIZE];
-};
-
 class PixmapCacheTreat {
 public:
     static inline pixman_image_t *get(pixman_image_t *surf)
@@ -201,44 +106,6 @@ public:
     }
 };

-class SpiceImageSurfacesBase;
-
-typedef CHash<SpiceCanvas, 1024, SpiceImageSurfacesBase> CSurfaces;
-
-class SpiceImageSurfacesBase {
-public:
-    SpiceImageSurfaces base;
-
-    static void op_put(SpiceImageSurfaces *c, uint32_t surface_id, SpiceCanvas *surface)
-    {
-        CSurfaces* cache = reinterpret_cast<CSurfaces*>(c);
-        cache->add(surface_id, surface);
-    }
-
-    static SpiceCanvas* op_get(SpiceImageSurfaces *s, uint32_t surface_id)
-    {
-        CSurfaces* cache = reinterpret_cast<CSurfaces*>(s);
-        return cache->get(surface_id);
-    }
-
-    static void op_del(SpiceImageSurfaces *c, uint32_t surface_id)
-    {
-        CSurfaces* cache = reinterpret_cast<CSurfaces*>(c);
-        cache->remove(surface_id);
-    }
-
-    SpiceImageSurfacesBase()
-    {
-        static SpiceImageSurfacesOps cache_ops = {
-            op_get
-        };
-        base.ops = &cache_ops;
-    }
-};
-
-class Canvas;
-
-typedef CHash<Canvas, 1024, SpiceImageSurfacesBase> CCanvases;

 class CachedPalette {
 public:
@@ -400,10 +267,20 @@ public:
     }
 };

+class Canvas;
+
+typedef std::map<uint32_t, Canvas*> SurfacesCanvasesMap;
+
+class SurfacesCache: public SpiceImageSurfaces, public SurfacesCanvasesMap {
+public:
+    SurfacesCache();
+    bool exist(uint32_t surface_id);
+};
+
 class Canvas {
 public:
     Canvas(PixmapCache& bits_cache, PaletteCache& palette_cache,
-           GlzDecoderWindow &glz_decoder_window, CSurfaces& csurfaces);
+           GlzDecoderWindow &glz_decoder_window, SurfacesCache& csurfaces);
     virtual ~Canvas();

     virtual void copy_pixels(const QRegion& region, RedDrawable* dc,
@@ -443,7 +320,7 @@ protected:

     PixmapCache& pixmap_cache() { return _pixmap_cache;}
     PaletteCache& palette_cache() { return _palette_cache;}
-    CSurfaces& csurfaces() { return _csurfaces; }
+    SurfacesCache& surfaces_cache() { return _surfaces_cache;}

     GlzDecoder& glz_decoder() {return _glz_decoder;}
     JpegDecoder& jpeg_decoder() { return _jpeg_decoder;}
@@ -454,7 +331,6 @@ private:

 protected:
     SpiceCanvas* _canvas;
-    CSurfaces _surfaces;

 private:
     PixmapCache& _pixmap_cache;
@@ -467,7 +343,7 @@ private:
     JpegDecoder _jpeg_decoder;
     ZlibDecoder _zlib_decoder;

-    CSurfaces& _csurfaces;
+    SurfacesCache& _surfaces_cache;

     unsigned long _base;
     unsigned long _max;
diff --git a/client/display_channel.cpp b/client/display_channel.cpp
index ea0623c..6127a96 100644
--- a/client/display_channel.cpp
+++ b/client/display_channel.cpp
@@ -544,42 +544,6 @@ void ResetTimer::response(AbstractProcessLoop& events_loop)
     _client.deactivate_interval_timer(this);
 }

-void DisplaySurfacesManger::add_surface(int surface_id, SpiceCanvas *surface)
-{
-     surfaces.add(surface_id, surface);
-}
-
-void DisplaySurfacesManger::del_surface(int surface_id)
-{
-    surfaces.remove(surface_id);
-}
-
-void DisplaySurfacesManger::add_canvas(int surface_id, Canvas *canvas)
-{
-    canvases.add(surface_id, canvas);
-}
-
-void DisplaySurfacesManger::del_canvas(int surface_id)
-{
-    canvases.remove(surface_id);
-}
-
-CSurfaces& DisplaySurfacesManger::get_surfaces()
-{
-    return surfaces;
-}
-
-bool DisplaySurfacesManger::is_present_canvas(int surface_id)
-{
-
-    return canvases.is_present(surface_id);
-}
-
-Canvas* DisplaySurfacesManger::get_canvas(int surface_id)
-{
-    return canvases.get(surface_id);
-}
-
 class DisplayHandler: public MessageHandlerImp<DisplayChannel, SPICE_CHANNEL_DISPLAY> {
 public:
     DisplayHandler(DisplayChannel& channel)
@@ -716,11 +680,11 @@ void DisplayChannel::copy_pixels(const QRegion& dest_region,
 {
     Canvas *canvas;

-    if (!surfaces_mngr.is_present_canvas(0)) {
+    if (!_surfaces_cache.exist(0)) {
         return;
     }

-    canvas = surfaces_mngr.get_canvas(0);
+    canvas = _surfaces_cache[0];
     canvas->copy_pixels(dest_region, NULL, &dest_pixmap);
 }

@@ -729,8 +693,8 @@ void DisplayChannel::recreate_ogl_context_interrupt()
 {
     Canvas* canvas;

-    if (surfaces_mngr.is_present_canvas(0)) { //fix me to all surfaces
-        canvas = surfaces_mngr.get_canvas(0);
+    if (_surfaces_cache.exist(0)) { //fix me to all surfaces
+        canvas = _surfaces_cache[0];
         ((GCanvas *)(canvas))->touch_context();
         ((GCanvas *)canvas)->textures_lost();
         delete canvas;
@@ -740,13 +704,13 @@ void DisplayChannel::recreate_ogl_context_interrupt()
         THROW("create_ogl_canvas failed");
     }

-    canvas = surfaces_mngr.get_canvas(0);
+    canvas = _surfaces_cache[0];
     ((GCanvas *)(canvas))->touch_context();
 }

 void DisplayChannel::recreate_ogl_context()
 {
-    if (surfaces_mngr.is_present_canvas(0) && surfaces_mngr.get_canvas(0)->get_pixmap_type() ==
+    if (_surfaces_cache.exist(0) && _surfaces_cache[0]->get_pixmap_type() ==
         CANVAS_TYPE_GL) {
         if (!screen()->need_recreate_context_gl()) {
             _gl_interrupt_recreate.trigger();
@@ -886,12 +850,12 @@ void DisplayChannel::update_interrupt()
     Canvas *canvas;
 #endif

-    if (!surfaces_mngr.is_present_canvas(0) || !screen()) {
+    if (!_surfaces_cache.exist(0) || !screen()) {
         return;
     }

 #ifdef USE_OGL
-    canvas = surfaces_mngr.get_canvas(0);
+    canvas = _surfaces_cache[0];
     if (canvas->get_pixmap_type() == CANVAS_TYPE_GL) {
         ((GCanvas *)(canvas))->pre_gl_copy();
     }
@@ -915,7 +879,7 @@ void DisplayChannel::pre_migrate()
 void DisplayChannel::post_migrate()
 {
 #ifdef USE_OGL
-    if (surfaces_mngr.get_canvas(0)->get_pixmap_type() == CANVAS_TYPE_GL) {
+    if (_surfaces_cache.exist(0) && _surfaces_cache[0]->get_pixmap_type() == CANVAS_TYPE_GL) {
         _gl_interrupt_recreate.trigger();
     }
 #endif
@@ -926,15 +890,11 @@ void DisplayChannel::post_migrate()
 void DisplayChannel::copy_pixels(const QRegion& dest_region,
                                  RedDrawable& dest_dc)
 {
-    Canvas *canvas;
-
-    if (!surfaces_mngr.is_present_canvas(0)) {
+    if (!_surfaces_cache.exist(0)) {
         return;
     }

-    canvas = surfaces_mngr.get_canvas(0);
-
-    canvas->copy_pixels(dest_region, dest_dc);
+    _surfaces_cache[0]->copy_pixels(dest_region, dest_dc);
 }

 class ActivateTimerEvent: public Event {
@@ -1040,11 +1000,8 @@ void DisplayChannel::on_connect()

 void DisplayChannel::on_disconnect()
 {
-    if (surfaces_mngr.is_present_canvas(0)) {
-        Canvas *canvas;
-
-        canvas = surfaces_mngr.get_canvas(0);
-        canvas->clear();
+    if (_surfaces_cache.exist(0)) {
+        _surfaces_cache[0]->clear();
     }

     if (screen()) {
@@ -1070,9 +1027,8 @@ bool DisplayChannel::create_sw_canvas(int surface_id, int width, int height, uin
         SCanvas *canvas = new SCanvas(surface_id == 0, width, height, format,
                                       screen()->get_window(),
                                       _pixmap_cache, _palette_cache, _glz_window,
-                                      surfaces_mngr.get_surfaces());
-        surfaces_mngr.add_canvas(surface_id, canvas);
-        surfaces_mngr.add_surface(surface_id, canvas->get_internal_canvas());
+                                      _surfaces_cache);
+        _surfaces_cache[surface_id] = canvas;
         if (surface_id == 0) {
             LOG_INFO("display %d: using sw", get_id());
         }
@@ -1094,12 +1050,11 @@ bool DisplayChannel::create_ogl_canvas(int surface_id, int width, int height, ui
                                       _pixmap_cache,
                                       _palette_cache,
                                       _glz_window,
-                                      surfaces_mngr.get_surfaces());
+                                      _surfaces_cache);

         screen()->untouch_context();

-        surfaces_mngr.add_canvas(surface_id, canvas);
-        surfaces_mngr.add_surface(surface_id, canvas->get_internal_canvas());
+        _surfaces_cache[surface_id] = canvas;
         _rendertype = rendertype;
         if (surface_id == 0) {
             LOG_INFO("display %d: using ogl", get_id());
@@ -1118,9 +1073,8 @@ bool DisplayChannel::create_gdi_canvas(int surface_id, int width, int height, ui
     try {
         GDICanvas *canvas = new GDICanvas(width, height, format,
                                           _pixmap_cache, _palette_cache, _glz_window,
-                                          surfaces_mngr.get_surfaces());
-        surfaces_mngr.add_canvas(surface_id, canvas);
-        surfaces_mngr.add_surface(surface_id, canvas->get_internal_canvas());
+                                          _surfaces_cache);
+        _surfaces_cache[surface_id] = canvas;
         if (surface_id == 0) {
             LOG_INFO("display %d: using gdi", get_id());
         }
@@ -1136,11 +1090,13 @@ void DisplayChannel::destroy_canvas(int surface_id)
 {
     Canvas *canvas;

-    if (!surfaces_mngr.is_present_canvas(surface_id)) {
+    if (!_surfaces_cache.exist(surface_id)) {
+        LOG_INFO("surface does not exist: %d", surface_id);
         return;
     }

-    canvas = surfaces_mngr.get_canvas(surface_id);
+    canvas = _surfaces_cache[surface_id];
+    _surfaces_cache.erase(surface_id);

 #ifdef USE_OGL
     if (canvas->get_pixmap_type() == CANVAS_TYPE_GL) {
@@ -1148,9 +1104,6 @@ void DisplayChannel::destroy_canvas(int surface_id)
     }
 #endif

-    surfaces_mngr.del_canvas(surface_id);
-    surfaces_mngr.del_surface(surface_id);
-
     delete canvas;
 }

@@ -1168,10 +1121,13 @@ void DisplayChannel::create_canvas(int surface_id, const std::vector<int>& canva
             recreate = false;
         }
 #endif
-
         screen()->set_update_interrupt_trigger(NULL);
     }

+    if (_surfaces_cache.exist(surface_id)) {
+        LOG_WARN("surface already exists: %d", surface_id);
+    }
+
     for (i = 0; i < canvas_types.size(); i++) {

         if (canvas_types[i] == CANVAS_OPTION_SW && create_sw_canvas(surface_id, width, height, format)) {
@@ -1205,7 +1161,7 @@ void DisplayChannel::handle_mode(RedPeer::InMessage* message)
 {
     SpiceMsgDisplayMode *mode = (SpiceMsgDisplayMode *)message->data();

-    if (surfaces_mngr.is_present_canvas(0)) {
+    if (_surfaces_cache.exist(0)) {
         destroy_primary_surface();
     }
     create_primary_surface(mode->x_res, mode->y_res,
@@ -1241,10 +1197,8 @@ void DisplayChannel::reset_screen()

 void DisplayChannel::handle_reset(RedPeer::InMessage *message)
 {
-    if (surfaces_mngr.is_present_canvas(0)) {
-        Canvas *canvas;
-        canvas = surfaces_mngr.get_canvas(0);
-        canvas->clear();
+    if (_surfaces_cache.exist(0)) {
+        _surfaces_cache[0]->clear();
     }

     _palette_cache.clear();
@@ -1323,10 +1277,14 @@ void DisplayChannel::handle_stream_create(RedPeer::InMessage* message)
         THROW("stream exist");
     }

+    if (!_surfaces_cache.exist(surface_id)) {
+        THROW("surface does not exist: %d", surface_id);
+    }
+
     uint32_t num_clip_rects;
     SpiceRect* clip_rects;
     set_clip_rects(stream_create->clip, num_clip_rects, clip_rects);
-    _streams[stream_create->id] = new VideoStream(get_client(), *surfaces_mngr.get_canvas(surface_id),
+    _streams[stream_create->id] = new VideoStream(get_client(), *_surfaces_cache[surface_id],
                                                   *this, stream_create->codec_type,
                                                   !!(stream_create->flags & SPICE_STREAM_FLAGS_TOP_DOWN),
                                                   stream_create->stream_width,
@@ -1429,7 +1387,7 @@ void DisplayChannel::create_primary_surface(int width, int height, uint32_t form
     _format = format;

 #ifdef USE_OGL
-    canvas = surfaces_mngr.get_canvas(0);
+    canvas = _surfaces_cache[0];

     if (canvas->get_pixmap_type() == CANVAS_TYPE_GL) {
         ((GCanvas *)(canvas))->touch_context();
@@ -1452,7 +1410,7 @@ void DisplayChannel::create_surface(int surface_id, int width, int height, uint3
 #ifdef USE_OGL
     Canvas *canvas;

-    canvas = surfaces_mngr.get_canvas(surface_id);
+    canvas = _surfaces_cache[surface_id];

     if (canvas->get_pixmap_type() == CANVAS_TYPE_GL) {
         ((GCanvas *)(canvas))->touch_context();
@@ -1464,11 +1422,8 @@ void DisplayChannel::destroy_primary_surface()
 {
     if (screen()) {
 #ifdef USE_OGL
-        if (surfaces_mngr.is_present_canvas(0)) {
-            Canvas *canvas;
-
-            canvas = surfaces_mngr.get_canvas(0);
-            if (canvas->get_pixmap_type() == CANVAS_TYPE_GL) {
+        if (_surfaces_cache.exist(0)) {
+            if (_surfaces_cache[0]->get_pixmap_type() == CANVAS_TYPE_GL) {
                 screen()->unset_type_gl();
                 screen()->untouch_context();
             }
@@ -1535,7 +1490,7 @@ void DisplayChannel::handle_copy_bits(RedPeer::InMessage* message)
     Canvas *canvas;
     SpiceMsgDisplayCopyBits* copy_bits = (SpiceMsgDisplayCopyBits*)message->data();
     PRE_DRAW;
-    canvas = surfaces_mngr.get_canvas(copy_bits->base.surface_id);
+    canvas = _surfaces_cache[copy_bits->base.surface_id];
     canvas->copy_bits(*copy_bits, message->size());
     POST_DRAW;
     if (copy_bits->base.surface_id == 0) {
@@ -1547,7 +1502,7 @@ void DisplayChannel::handle_draw_fill(RedPeer::InMessage* message)
 {
     Canvas *canvas;
     SpiceMsgDisplayDrawFill* fill = (SpiceMsgDisplayDrawFill*)message->data();
-    canvas = surfaces_mngr.get_canvas(fill->base.surface_id);
+    canvas = _surfaces_cache[fill->base.surface_id];
     DRAW(fill);
 }

@@ -1555,7 +1510,7 @@ void DisplayChannel::handle_draw_opaque(RedPeer::InMessage* message)
 {
     Canvas *canvas;
     SpiceMsgDisplayDrawOpaque* opaque = (SpiceMsgDisplayDrawOpaque*)message->data();
-    canvas = surfaces_mngr.get_canvas(opaque->base.surface_id);
+    canvas = _surfaces_cache[opaque->base.surface_id];
     DRAW(opaque);
 }

@@ -1563,7 +1518,7 @@ void DisplayChannel::handle_draw_copy(RedPeer::InMessage* message)
 {
     Canvas *canvas;
     SpiceMsgDisplayDrawCopy* copy = (SpiceMsgDisplayDrawCopy*)message->data();
-    canvas = surfaces_mngr.get_canvas(copy->base.surface_id);
+    canvas = _surfaces_cache[copy->base.surface_id];
     DRAW(copy);
 }

@@ -1571,7 +1526,7 @@ void DisplayChannel::handle_draw_blend(RedPeer::InMessage* message)
 {
     Canvas *canvas;
     SpiceMsgDisplayDrawBlend* blend = (SpiceMsgDisplayDrawBlend*)message->data();
-    canvas = surfaces_mngr.get_canvas(blend->base.surface_id);
+    canvas = _surfaces_cache[blend->base.surface_id];
     DRAW(blend);
 }

@@ -1579,7 +1534,7 @@ void DisplayChannel::handle_draw_blackness(RedPeer::InMessage* message)
 {
     Canvas *canvas;
     SpiceMsgDisplayDrawBlackness* blackness = (SpiceMsgDisplayDrawBlackness*)message->data();
-    canvas = surfaces_mngr.get_canvas(blackness->base.surface_id);
+    canvas = _surfaces_cache[blackness->base.surface_id];
     DRAW(blackness);
 }

@@ -1587,7 +1542,7 @@ void DisplayChannel::handle_draw_whiteness(RedPeer::InMessage* message)
 {
     Canvas *canvas;
     SpiceMsgDisplayDrawWhiteness* whiteness = (SpiceMsgDisplayDrawWhiteness*)message->data();
-    canvas = surfaces_mngr.get_canvas(whiteness->base.surface_id);
+    canvas = _surfaces_cache[whiteness->base.surface_id];
     DRAW(whiteness);
 }

@@ -1595,7 +1550,7 @@ void DisplayChannel::handle_draw_invers(RedPeer::InMessage* message)
 {
     Canvas *canvas;
     SpiceMsgDisplayDrawInvers* invers = (SpiceMsgDisplayDrawInvers*)message->data();
-    canvas = surfaces_mngr.get_canvas(invers->base.surface_id);
+    canvas = _surfaces_cache[invers->base.surface_id];
     DRAW(invers);
 }

@@ -1603,7 +1558,7 @@ void DisplayChannel::handle_draw_rop3(RedPeer::InMessage* message)
 {
     Canvas *canvas;
     SpiceMsgDisplayDrawRop3* rop3 = (SpiceMsgDisplayDrawRop3*)message->data();
-    canvas = surfaces_mngr.get_canvas(rop3->base.surface_id);
+    canvas = _surfaces_cache[rop3->base.surface_id];
     DRAW(rop3);
 }

@@ -1611,7 +1566,7 @@ void DisplayChannel::handle_draw_stroke(RedPeer::InMessage* message)
 {
     Canvas *canvas;
     SpiceMsgDisplayDrawStroke* stroke = (SpiceMsgDisplayDrawStroke*)message->data();
-    canvas = surfaces_mngr.get_canvas(stroke->base.surface_id);
+    canvas = _surfaces_cache[stroke->base.surface_id];
     DRAW(stroke);
 }

@@ -1619,7 +1574,7 @@ void DisplayChannel::handle_draw_text(RedPeer::InMessage* message)
 {
     Canvas *canvas;
     SpiceMsgDisplayDrawText* text = (SpiceMsgDisplayDrawText*)message->data();
-    canvas = surfaces_mngr.get_canvas(text->base.surface_id);
+    canvas = _surfaces_cache[text->base.surface_id];
     DRAW(text);
 }

@@ -1627,7 +1582,7 @@ void DisplayChannel::handle_draw_transparent(RedPeer::InMessage* message)
 {
     Canvas *canvas;
     SpiceMsgDisplayDrawTransparent* transparent = (SpiceMsgDisplayDrawTransparent*)message->data();
-    canvas = surfaces_mngr.get_canvas(transparent->base.surface_id);
+    canvas = _surfaces_cache[transparent->base.surface_id];
     DRAW(transparent);
 }

@@ -1635,7 +1590,7 @@ void DisplayChannel::handle_draw_alpha_blend(RedPeer::InMessage* message)
 {
     Canvas *canvas;
     SpiceMsgDisplayDrawAlphaBlend* alpha_blend = (SpiceMsgDisplayDrawAlphaBlend*)message->data();
-    canvas = surfaces_mngr.get_canvas(alpha_blend->base.surface_id);
+    canvas = _surfaces_cache[alpha_blend->base.surface_id];
     DRAW(alpha_blend);
 }

diff --git a/client/display_channel.h b/client/display_channel.h
index e6cd227..cdad5ff 100644
--- a/client/display_channel.h
+++ b/client/display_channel.h
@@ -80,21 +80,6 @@ private:
     DisplayChannel& _channel;
 };

-class DisplaySurfacesManger {
-public:
-    void add_surface(int surface_id, SpiceCanvas *surface);
-    void del_surface(int surface_id);
-    void add_canvas(int surface_id, Canvas *canvas);
-    void del_canvas(int surface_id);
-
-    CSurfaces& get_surfaces();
-    bool is_present_canvas(int surface_id);
-    Canvas* get_canvas(int surface_id);
-private:
-    CSurfaces surfaces;
-    CCanvases canvases;
-};
-
 class DisplayChannel: public RedChannel, public ScreenLayer {
 public:
     DisplayChannel(RedClient& client, uint32_t id,
@@ -191,8 +176,9 @@ private:
     void reset_screen();

     static void set_clip_rects(const SpiceClip& clip, uint32_t& num_clip_rects, SpiceRect*& clip_rects);
+
 private:
-    DisplaySurfacesManger surfaces_mngr;
+    SurfacesCache _surfaces_cache;
     PixmapCache& _pixmap_cache;
     PaletteCache _palette_cache;
     GlzDecoderWindow& _glz_window;
diff --git a/client/red_gdi_canvas.cpp b/client/red_gdi_canvas.cpp
index 72b31df..0c38832 100644
--- a/client/red_gdi_canvas.cpp
+++ b/client/red_gdi_canvas.cpp
@@ -25,7 +25,7 @@

 GDICanvas::GDICanvas(int width, int height, uint32_t format,
 		     PixmapCache& pixmap_cache, PaletteCache& palette_cache,
-                     GlzDecoderWindow &glz_decoder_window, CSurfaces &csurfaces)
+                     GlzDecoderWindow &glz_decoder_window, SurfacesCache &csurfaces)
     : Canvas (pixmap_cache, palette_cache, glz_decoder_window, csurfaces)
     , _pixmap (0)
 {
@@ -36,7 +36,7 @@ GDICanvas::GDICanvas(int width, int height, uint32_t format,
                                       &_pixmap->get_mutex(),
                                       format, &pixmap_cache.base,
                                       &palette_cache.base,
-                                      &csurfaces.base,
+                                      &csurfaces,
                                       &glz_decoder(),
                                       &jpeg_decoder(),
                                       &zlib_decoder()))) {
diff --git a/client/red_gdi_canvas.h b/client/red_gdi_canvas.h
index 643f3c6..b88c298 100644
--- a/client/red_gdi_canvas.h
+++ b/client/red_gdi_canvas.h
@@ -29,7 +29,7 @@ class GDICanvas: public Canvas {
 public:
     GDICanvas(int width, int height, uint32_t format,
 	      PixmapCache& pixmap_cache, PaletteCache& palette_cache,
-              GlzDecoderWindow &glz_decoder_window, CSurfaces &csurfaces);
+              GlzDecoderWindow &glz_decoder_window, SurfacesCache &csurfaces);
     virtual ~GDICanvas();

     virtual void thread_touch() {}
diff --git a/client/red_gl_canvas.cpp b/client/red_gl_canvas.cpp
index d7841b9..e2bff7f 100644
--- a/client/red_gl_canvas.cpp
+++ b/client/red_gl_canvas.cpp
@@ -27,7 +27,7 @@
 GCanvas::GCanvas(int width, int height, uint32_t format, RedWindow *win,
                  RenderType rendertype,
                  PixmapCache& pixmap_cache, PaletteCache& palette_cache,
-                 GlzDecoderWindow &glz_decoder_window, CSurfaces &csurfaces)
+                 GlzDecoderWindow &glz_decoder_window, SurfacesCache &csurfaces)
     : Canvas(pixmap_cache, palette_cache, glz_decoder_window, csurfaces)
     , _pixmap (0)
     , _textures_lost (false)
@@ -39,7 +39,7 @@ GCanvas::GCanvas(int width, int height, uint32_t format, RedWindow *win,
                                      SPICE_SURFACE_FMT_DEPTH(format),
                                      &pixmap_cache.base,
                                      &palette_cache.base,
-                                     &csurfaces.base,
+                                     &csurfaces,
                                      &glz_decoder(),
                                      &jpeg_decoder(),
                                      &zlib_decoder()))) {
diff --git a/client/red_gl_canvas.h b/client/red_gl_canvas.h
index 0260958..8c19882 100644
--- a/client/red_gl_canvas.h
+++ b/client/red_gl_canvas.h
@@ -31,7 +31,7 @@ public:
     GCanvas(int width, int height, uint32_t format, RedWindow *win,
             RenderType rendertype,
             PixmapCache& pixmap_cache, PaletteCache& palette_cache,
-            GlzDecoderWindow &glz_decoder_window, CSurfaces &csurfaces);
+            GlzDecoderWindow &glz_decoder_window, SurfacesCache &csurfaces);
     virtual ~GCanvas();

     void set_mode();
diff --git a/client/red_sw_canvas.cpp b/client/red_sw_canvas.cpp
index b580e61..08d4e09 100644
--- a/client/red_sw_canvas.cpp
+++ b/client/red_sw_canvas.cpp
@@ -28,7 +28,7 @@
 SCanvas::SCanvas(bool onscreen,
                  int width, int height, uint32_t format, RedWindow *win,
                  PixmapCache& pixmap_cache, PaletteCache& palette_cache,
-                 GlzDecoderWindow &glz_decoder_window, CSurfaces& csurfaces)
+                 GlzDecoderWindow &glz_decoder_window, SurfacesCache& csurfaces)
     : Canvas (pixmap_cache, palette_cache, glz_decoder_window, csurfaces)
     , _pixmap (0)
 {
@@ -41,7 +41,7 @@ SCanvas::SCanvas(bool onscreen,
                                          _pixmap->get_stride(),
                                          &pixmap_cache.base,
                                          &palette_cache.base,
-                                         &csurfaces.base,
+                                         &csurfaces,
                                          &glz_decoder(),
                                          &jpeg_decoder(),
                                          &zlib_decoder());
@@ -49,7 +49,7 @@ SCanvas::SCanvas(bool onscreen,
         _canvas = canvas_create(width, height, format,
                                 &pixmap_cache.base,
                                 &palette_cache.base,
-                                &csurfaces.base,
+                                &csurfaces,
                                 &glz_decoder(),
                                 &jpeg_decoder(),
                                 &zlib_decoder());
diff --git a/client/red_sw_canvas.h b/client/red_sw_canvas.h
index ebac710..cf97d1d 100644
--- a/client/red_sw_canvas.h
+++ b/client/red_sw_canvas.h
@@ -29,7 +29,7 @@ public:
     SCanvas(bool onscreen,
             int width, int height, uint32_t format, RedWindow *win,
             PixmapCache& pixmap_cache, PaletteCache& palette_cache,
-            GlzDecoderWindow &glz_decoder_window, CSurfaces &csurfaces);
+            GlzDecoderWindow &glz_decoder_window, SurfacesCache &csurfaces);
     virtual ~SCanvas();

     virtual void thread_touch() {}
-- 
1.7.6.2

